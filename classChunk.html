<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>Roguelike: Chunk Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Roguelike
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classChunk-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Chunk Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="chunk_8h_source.html">chunk.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc32e1562cad6664c98ee07edecdbdf9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#acc32e1562cad6664c98ee07edecdbdf9">Chunk</a> ()</td></tr>
<tr class="separator:acc32e1562cad6664c98ee07edecdbdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1477910be4a6624f8525aea6016ec00"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#ac1477910be4a6624f8525aea6016ec00">Chunk</a> (<a class="el" href="structMapTile.html">MapTile</a> tile_type, int _world_row, int _world_col)</td></tr>
<tr class="separator:ac1477910be4a6624f8525aea6016ec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b0e812445af49d81e4d219feaac9b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a97b0e812445af49d81e4d219feaac9b6">init</a> (<a class="el" href="structMapTile.html">MapTile</a> tile_type, int _world_row, int _world_col)</td></tr>
<tr class="separator:a97b0e812445af49d81e4d219feaac9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a934bbc30f35c29a3f8e94949efbcb742"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a934bbc30f35c29a3f8e94949efbcb742">build_chunk_with_dungeons</a> ()</td></tr>
<tr class="separator:a934bbc30f35c29a3f8e94949efbcb742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f977a140e893bbff3050bb4e8c079d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a48f977a140e893bbff3050bb4e8c079d">build_land_chunk</a> ()</td></tr>
<tr class="separator:a48f977a140e893bbff3050bb4e8c079d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5950688f0d49382090f9776d75aa4bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a5950688f0d49382090f9776d75aa4bba">build_forest_chunk</a> ()</td></tr>
<tr class="separator:a5950688f0d49382090f9776d75aa4bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf2ac9ff8f307d5a147f125346509f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#acbf2ac9ff8f307d5a147f125346509f8">build_water_chunk</a> ()</td></tr>
<tr class="separator:acbf2ac9ff8f307d5a147f125346509f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af064ef9d4d612eda73d5689ea01c5c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#af064ef9d4d612eda73d5689ea01c5c53">build_beach_chunk</a> ()</td></tr>
<tr class="separator:af064ef9d4d612eda73d5689ea01c5c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0859a84d6b25dc828bbb1173f04818f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIntPoint.html">IntPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#ad0859a84d6b25dc828bbb1173f04818f">get_world_loc</a> () const </td></tr>
<tr class="separator:ad0859a84d6b25dc828bbb1173f04818f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2958e53b1d3e98f4fc1df97793c8fa0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIntPoint.html">IntPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#ad2958e53b1d3e98f4fc1df97793c8fa0">get_up_stair</a> (int depth) const </td></tr>
<tr class="separator:ad2958e53b1d3e98f4fc1df97793c8fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4fc53a661eee7f8d1b23e69418e4e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIntPoint.html">IntPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#abf4fc53a661eee7f8d1b23e69418e4e6">get_down_stair</a> (int depth) const </td></tr>
<tr class="separator:abf4fc53a661eee7f8d1b23e69418e4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cec15851750a347fe9c6e423a4d3cfb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classItem.html">Item</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a9cec15851750a347fe9c6e423a4d3cfb">get_items</a> (int depth)</td></tr>
<tr class="separator:a9cec15851750a347fe9c6e423a4d3cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50189addc809f746695c28984fa33c16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a50189addc809f746695c28984fa33c16">remove_item</a> (<a class="el" href="classItem.html">Item</a> *item, int depth)</td></tr>
<tr class="separator:a50189addc809f746695c28984fa33c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9984ca5fcd45ba8583f85353ed4c2fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#ab9984ca5fcd45ba8583f85353ed4c2fd">add_item</a> (<a class="el" href="classItem.html">Item</a> *item, int depth)</td></tr>
<tr class="separator:ab9984ca5fcd45ba8583f85353ed4c2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2c4a89cf89f207a98df2ad162f5b5d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector<br class="typebreak" />
&lt; <a class="el" href="structTile.html">Tile</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#acc2c4a89cf89f207a98df2ad162f5b5d">get_floor</a> (int depth)</td></tr>
<tr class="separator:acc2c4a89cf89f207a98df2ad162f5b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92efc69d6a38f6106058186d2411816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structTile.html">Tile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#aa92efc69d6a38f6106058186d2411816">get_tile</a> (int depth, int row, int col)</td></tr>
<tr class="separator:aa92efc69d6a38f6106058186d2411816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d43a6a8f3011f6445ee0c31f62877a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a94d43a6a8f3011f6445ee0c31f62877a">set_tile</a> (int depth, int row, int col, <a class="el" href="structTile.html">Tile</a> tile)</td></tr>
<tr class="separator:a94d43a6a8f3011f6445ee0c31f62877a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c78b6c6f3d6f660b92078acd4eb797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#ad3c78b6c6f3d6f660b92078acd4eb797">get_depth</a> () const </td></tr>
<tr class="separator:ad3c78b6c6f3d6f660b92078acd4eb797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf554ea4bbee217b91058513dcd09e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#aecf554ea4bbee217b91058513dcd09e0">out_of_bounds</a> (int depth, int row, int col) const </td></tr>
<tr class="separator:aecf554ea4bbee217b91058513dcd09e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67062bac6593c8f49ed93bed22036c4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSpawner.html">Spawner</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a67062bac6593c8f49ed93bed22036c4c">get_spawner</a> (int depth)</td></tr>
<tr class="separator:a67062bac6593c8f49ed93bed22036c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa427d58d8811b0c95d21e8c597d4e1c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#aa427d58d8811b0c95d21e8c597d4e1c6">dungeon_dump</a> (int depth)</td></tr>
<tr class="separator:aa427d58d8811b0c95d21e8c597d4e1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dce33f5d2a329b2da236ab4a6aba96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMapTile.html">MapTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#ae5dce33f5d2a329b2da236ab4a6aba96">get_type</a> ()</td></tr>
<tr class="separator:ae5dce33f5d2a329b2da236ab4a6aba96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d96e01d14e83bebc40ee1f1e10c918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#ac3d96e01d14e83bebc40ee1f1e10c918">serialize</a> ()</td></tr>
<tr class="separator:ac3d96e01d14e83bebc40ee1f1e10c918"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ad9221ac3c0a7116f8f4514904f48bb3a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad9221ac3c0a7116f8f4514904f48bb3a"></a>
typedef std::vector<br class="typebreak" />
&lt; std::vector&lt; <a class="el" href="structTile.html">Tile</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TileMatrix</b></td></tr>
<tr class="separator:ad9221ac3c0a7116f8f4514904f48bb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a319c4b394a290371c77e61dbfac701aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a319c4b394a290371c77e61dbfac701aa">find_serialized_chunk</a> ()</td></tr>
<tr class="separator:a319c4b394a290371c77e61dbfac701aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d85f3b9e30641318eb5d15277235de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#ab9d85f3b9e30641318eb5d15277235de">calculate_file_size</a> (int bytes_per_tile)</td></tr>
<tr class="separator:ab9d85f3b9e30641318eb5d15277235de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7911e6a7955344a83fb4c7bd335a84e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a7911e6a7955344a83fb4c7bd335a84e6">deserialize</a> (string file_name)</td></tr>
<tr class="separator:a7911e6a7955344a83fb4c7bd335a84e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a90f5a4d10b0f6d92d144c452517d38a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90f5a4d10b0f6d92d144c452517d38a1"></a>
<a class="el" href="structchunk__meta.html">chunk_meta</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cm</b></td></tr>
<tr class="separator:a90f5a4d10b0f6d92d144c452517d38a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e284b0073b458de75ef397db45079ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structMapTile.html">MapTile</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#a2e284b0073b458de75ef397db45079ee">chunk_type</a></td></tr>
<tr class="separator:a2e284b0073b458de75ef397db45079ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6215d7a0e78cf12228a58eb6d5a4ae"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classChunkLayer.html">ChunkLayer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChunk.html#afc6215d7a0e78cf12228a58eb6d5a4ae">layers</a></td></tr>
<tr class="separator:afc6215d7a0e78cf12228a58eb6d5a4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classChunk.html">Chunk</a> class is the largest data model in the game.</p>
<p>Each <a class="el" href="classChunk.html">Chunk</a> contains a vector of dungeons and an overworld. Chunks are in charge of their own loading method: When a new chunk is constructed or its <a class="el" href="classChunk.html#a97b0e812445af49d81e4d219feaac9b6">init()</a> method is called (the first implies the second), it will look in the chunk data folder to see if the chunk at its coordinates has previously been serialized. If not, the chunk controls its own creation, and if so, the chunk calls its <a class="el" href="classChunk.html#a7911e6a7955344a83fb4c7bd335a84e6">deserialize()</a> method, loading it with the appropriate data. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acc32e1562cad6664c98ee07edecdbdf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Chunk::Chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty constructor.</p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000022">Todo:</a></b></dt><dd>check if this can be empty. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1477910be4a6624f8525aea6016ec00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Chunk::Chunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMapTile.html">MapTile</a>&#160;</td>
          <td class="paramname"><em>tile_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_world_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_world_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typical use case constructor. Will handle file deserialization by itself: When provided with a location, the function will decide whether or not it should deserialize an offloaded chunk.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_type</td><td>- the type of the map tile on which this chunk lies. </td></tr>
    <tr><td class="paramname">_world_col</td><td>- The row of this chunk's location on the world map. </td></tr>
    <tr><td class="paramname">_world_col</td><td>- The column of this chunk's location on the world map.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structMapTile.html">MapTile</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab9984ca5fcd45ba8583f85353ed4c2fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::add_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will add the given item to the chunk's item list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- a pointer to the item to add </td></tr>
    <tr><td class="paramname">depth</td><td>- the depth at which to add the item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af064ef9d4d612eda73d5689ea01c5c53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::build_beach_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a chunk with only a sandy overworld. </p>

</div>
</div>
<a class="anchor" id="a934bbc30f35c29a3f8e94949efbcb742"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chunk::build_chunk_with_dungeons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>this documentation </dd></dl>

</div>
</div>
<a class="anchor" id="a5950688f0d49382090f9776d75aa4bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::build_forest_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a chunk with grass, trees, groves, and dungeons. </p>

</div>
</div>
<a class="anchor" id="a48f977a140e893bbff3050bb4e8c079d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::build_land_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a chunk with dirt, trees, and dungeons. Behaves as the default overworld. </p>

</div>
</div>
<a class="anchor" id="acbf2ac9ff8f307d5a147f125346509f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::build_water_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a chunk with only a watery overworld. </p>

</div>
</div>
<a class="anchor" id="ab9d85f3b9e30641318eb5d15277235de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Chunk::calculate_file_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bytes_per_tile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines the size of the file that will be created for this chunk. </p><dl class="section return"><dt>Returns</dt><dd>integer file size in bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a7911e6a7955344a83fb4c7bd335a84e6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::deserialize </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads this chunk's information from a file. Essentially does a simple reverse of the serialization process. The "header" bytes, which always must exist in the file, are processed one-by-one and loaded into the class member variables to restore the data. Then, data which may or may not exist (such as stair/spawner locations) is loaded based on header information. Next, the bytes of the dungeon and overworld are loaded in a triple-nested for-loop.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file_name</td><td>- The name of the file from which the chunk will be loaded. </td></tr>
    <tr><td class="paramname">world_row</td><td>- This chunk's row on the world map. </td></tr>
    <tr><td class="paramname">world_col</td><td>- This chunk's column on the world map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>does this have to be dynamically allocated? </dd></dl>
<p>TODO still differentiating between overworld and dungeons here.</p>

</div>
</div>
<a class="anchor" id="aa427d58d8811b0c95d21e8c597d4e1c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::dungeon_dump </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints a graphical representation of the given layer to stdout. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- the depth of the layer to print. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a319c4b394a290371c77e61dbfac701aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Chunk::find_serialized_chunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The entry point for deserialization. Will attempt to find an offloaded chunk with the given coordinates. If an offloaded chunk is found in the filesystem, calls the <a class="el" href="classChunk.html#a7911e6a7955344a83fb4c7bd335a84e6">deserialize()</a> function and returns true. Otherwise, returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row</td><td>- The world row of the chunk to find. </td></tr>
    <tr><td class="paramname">col</td><td>- The world column of the chunk to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether or not a serialized chunk was found. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classChunk.html#a7911e6a7955344a83fb4c7bd335a84e6">deserialize</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3c78b6c6f3d6f660b92078acd4eb797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Chunk::get_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine how many layers are beneath the overworld in this chunk. </p><dl class="section return"><dt>Returns</dt><dd>the depth. </dd></dl>

</div>
</div>
<a class="anchor" id="abf4fc53a661eee7f8d1b23e69418e4e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntPoint.html">IntPoint</a> Chunk::get_down_stair </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the location of the down stair in the chunk as an <a class="el" href="classIntPoint.html">IntPoint</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- the depth of this chunk. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc2c4a89cf89f207a98df2ad162f5b5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; <a class="el" href="structTile.html">Tile</a> &gt; &gt; &amp; Chunk::get_floor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- the depth to get (-1 is the overworld) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the TileMatrix of the given floor </dd></dl>

</div>
</div>
<a class="anchor" id="a9cec15851750a347fe9c6e423a4d3cfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classItem.html">Item</a> * &gt; &amp; Chunk::get_items </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of all the items on the ground in this chunk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- the depth of this chunk. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a vector of items in the chunk. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>should this return a reference instead of a pointer? </dd></dl>

</div>
</div>
<a class="anchor" id="a67062bac6593c8f49ed93bed22036c4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSpawner.html">Spawner</a> Chunk::get_spawner </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the spawner object at the given depth. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the spawner object </dd></dl>

</div>
</div>
<a class="anchor" id="aa92efc69d6a38f6106058186d2411816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structTile.html">Tile</a> * Chunk::get_tile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td></td></tr>
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">col</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the tile at the given location. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5dce33f5d2a329b2da236ab4a6aba96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMapTile.html">MapTile</a> Chunk::get_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the type of chunk. </dd></dl>

</div>
</div>
<a class="anchor" id="ad2958e53b1d3e98f4fc1df97793c8fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntPoint.html">IntPoint</a> Chunk::get_up_stair </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the location of the up stair in the chunk as an <a class="el" href="classIntPoint.html">IntPoint</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- the depth of this chunk. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0859a84d6b25dc828bbb1173f04818f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIntPoint.html">IntPoint</a> Chunk::get_world_loc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an <a class="el" href="classIntPoint.html">IntPoint</a> representing the chunk's location on the world map. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>Just use an <a class="el" href="classIntPoint.html">IntPoint</a> to store world location in general. <dl class="section return"><dt>Returns</dt><dd>the chunk's location on the world map </dd></dl>
</dd></dl>

</div>
</div>
<a class="anchor" id="a97b0e812445af49d81e4d219feaac9b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structMapTile.html">MapTile</a>&#160;</td>
          <td class="paramname"><em>tile_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_world_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>_world_col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets all important information in the chunk, deserializing as needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tile_type</td><td>- The type of the map tile on which this chunk lies. </td></tr>
    <tr><td class="paramname">_world_row</td><td>- The row of this chunk's location on the world map. </td></tr>
    <tr><td class="paramname">_world_col</td><td>- The column of this chunk's location on the world map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classChunk.html#a7911e6a7955344a83fb4c7bd335a84e6">deserialize</a> </dd>
<dd>
<a class="el" href="structMapTile.html">MapTile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aecf554ea4bbee217b91058513dcd09e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chunk::out_of_bounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a point, will determine whether the point is out of bounds. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td></td></tr>
    <tr><td class="paramname">row</td><td></td></tr>
    <tr><td class="paramname">col</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given location is out of bounds on the chunk. </dd></dl>

</div>
</div>
<a class="anchor" id="a50189addc809f746695c28984fa33c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::remove_item </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classItem.html">Item</a> *&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will remove the given item from the chunk. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>- a pointer to the item to remove </td></tr>
    <tr><td class="paramname">depth</td><td>- the depth at which to remove the item. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac3d96e01d14e83bebc40ee1f1e10c918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::serialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves all of the important information for this chunk in a file. The file size is first carefully calculated, then a char array is created with that size and populated with the dungeon data. The file is saved in data/chunk.</p>
<p>Some bitwise arithmetic is used to pack ints and bools together in a single byte. As we get over 128 tile IDs, we will have to change this functionality. </p>
<p>if((cm.depth &lt; 0) || (cm.depth &gt; 10)) { cout&lt;&lt;"CHUNK DEPTH: "&lt;&lt;cm.depth&lt;&lt;endl; }</p>

</div>
</div>
<a class="anchor" id="a94d43a6a8f3011f6445ee0c31f62877a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chunk::set_tile </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structTile.html">Tile</a>&#160;</td>
          <td class="paramname"><em>tile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a tile at the given position to the given tile type. If the depth is -1, the tile will be set at the overworld.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>- the depth of this chunk. </td></tr>
    <tr><td class="paramname">row</td><td>- the row of the tile to set. </td></tr>
    <tr><td class="paramname">col</td><td>- the column of the tile to set. </td></tr>
    <tr><td class="paramname">tile</td><td>- the tile type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2e284b0073b458de75ef397db45079ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structMapTile.html">MapTile</a> Chunk::chunk_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The type of this chunk, found in <a class="el" href="defs_8h_source.html">defs.h</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structMapTile.html">MapTile</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afc6215d7a0e78cf12228a58eb6d5a4ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classChunkLayer.html">ChunkLayer</a>&gt; Chunk::layers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector containing the layers of this chunk. Generally this is the main data chokepoint in the <a class="el" href="classChunk.html">Chunk</a> class. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/world/<a class="el" href="chunk_8h_source.html">chunk.h</a></li>
<li>src/world/chunk.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 18 2014 10:53:50 for Roguelike by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
